// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "RNewsflow_types.h"
#include <RcppEigen.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// term_union_cpp
List term_union_cpp(SpMat& m, SpMat& simmat, std::vector<std::string> terms, std::vector<bool> parentheses, bool verbose, std::string sep);
RcppExport SEXP _RNewsflow_term_union_cpp(SEXP mSEXP, SEXP simmatSEXP, SEXP termsSEXP, SEXP parenthesesSEXP, SEXP verboseSEXP, SEXP sepSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SpMat& >::type m(mSEXP);
    Rcpp::traits::input_parameter< SpMat& >::type simmat(simmatSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type terms(termsSEXP);
    Rcpp::traits::input_parameter< std::vector<bool> >::type parentheses(parenthesesSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    Rcpp::traits::input_parameter< std::string >::type sep(sepSEXP);
    rcpp_result_gen = Rcpp::wrap(term_union_cpp(m, simmat, terms, parentheses, verbose, sep));
    return rcpp_result_gen;
END_RCPP
}
// term_intersect_cpp
List term_intersect_cpp(SpMat& m, SpMat& simmat, std::vector<std::string> terms, std::vector<bool> parentheses, bool verbose, std::string sep);
RcppExport SEXP _RNewsflow_term_intersect_cpp(SEXP mSEXP, SEXP simmatSEXP, SEXP termsSEXP, SEXP parenthesesSEXP, SEXP verboseSEXP, SEXP sepSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SpMat& >::type m(mSEXP);
    Rcpp::traits::input_parameter< SpMat& >::type simmat(simmatSEXP);
    Rcpp::traits::input_parameter< std::vector<std::string> >::type terms(termsSEXP);
    Rcpp::traits::input_parameter< std::vector<bool> >::type parentheses(parenthesesSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    Rcpp::traits::input_parameter< std::string >::type sep(sepSEXP);
    rcpp_result_gen = Rcpp::wrap(term_intersect_cpp(m, simmat, terms, parentheses, verbose, sep));
    return rcpp_result_gen;
END_RCPP
}
// batched_tcrossprod_cpp
List batched_tcrossprod_cpp(SpMat& m1, SpMat& m2, IntegerVector group1, IntegerVector group2, NumericVector order1, NumericVector order2, const SpMat& simmat, bool use_min, NumericVector min_value, bool use_max, NumericVector max_value, int top_n, bool diag, bool only_upper, bool rowsum_div, std::string pvalue, double max_p, std::string normalize, std::string crossfun, int lwindow, int rwindow, bool row_attr, bool col_attr, bool lag_attr, bool verbose, int batchsize);
RcppExport SEXP _RNewsflow_batched_tcrossprod_cpp(SEXP m1SEXP, SEXP m2SEXP, SEXP group1SEXP, SEXP group2SEXP, SEXP order1SEXP, SEXP order2SEXP, SEXP simmatSEXP, SEXP use_minSEXP, SEXP min_valueSEXP, SEXP use_maxSEXP, SEXP max_valueSEXP, SEXP top_nSEXP, SEXP diagSEXP, SEXP only_upperSEXP, SEXP rowsum_divSEXP, SEXP pvalueSEXP, SEXP max_pSEXP, SEXP normalizeSEXP, SEXP crossfunSEXP, SEXP lwindowSEXP, SEXP rwindowSEXP, SEXP row_attrSEXP, SEXP col_attrSEXP, SEXP lag_attrSEXP, SEXP verboseSEXP, SEXP batchsizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SpMat& >::type m1(m1SEXP);
    Rcpp::traits::input_parameter< SpMat& >::type m2(m2SEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type group1(group1SEXP);
    Rcpp::traits::input_parameter< IntegerVector >::type group2(group2SEXP);
    Rcpp::traits::input_parameter< NumericVector >::type order1(order1SEXP);
    Rcpp::traits::input_parameter< NumericVector >::type order2(order2SEXP);
    Rcpp::traits::input_parameter< const SpMat& >::type simmat(simmatSEXP);
    Rcpp::traits::input_parameter< bool >::type use_min(use_minSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type min_value(min_valueSEXP);
    Rcpp::traits::input_parameter< bool >::type use_max(use_maxSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type max_value(max_valueSEXP);
    Rcpp::traits::input_parameter< int >::type top_n(top_nSEXP);
    Rcpp::traits::input_parameter< bool >::type diag(diagSEXP);
    Rcpp::traits::input_parameter< bool >::type only_upper(only_upperSEXP);
    Rcpp::traits::input_parameter< bool >::type rowsum_div(rowsum_divSEXP);
    Rcpp::traits::input_parameter< std::string >::type pvalue(pvalueSEXP);
    Rcpp::traits::input_parameter< double >::type max_p(max_pSEXP);
    Rcpp::traits::input_parameter< std::string >::type normalize(normalizeSEXP);
    Rcpp::traits::input_parameter< std::string >::type crossfun(crossfunSEXP);
    Rcpp::traits::input_parameter< int >::type lwindow(lwindowSEXP);
    Rcpp::traits::input_parameter< int >::type rwindow(rwindowSEXP);
    Rcpp::traits::input_parameter< bool >::type row_attr(row_attrSEXP);
    Rcpp::traits::input_parameter< bool >::type col_attr(col_attrSEXP);
    Rcpp::traits::input_parameter< bool >::type lag_attr(lag_attrSEXP);
    Rcpp::traits::input_parameter< bool >::type verbose(verboseSEXP);
    Rcpp::traits::input_parameter< int >::type batchsize(batchsizeSEXP);
    rcpp_result_gen = Rcpp::wrap(batched_tcrossprod_cpp(m1, m2, group1, group2, order1, order2, simmat, use_min, min_value, use_max, max_value, top_n, diag, only_upper, rowsum_div, pvalue, max_p, normalize, crossfun, lwindow, rwindow, row_attr, col_attr, lag_attr, verbose, batchsize));
    return rcpp_result_gen;
END_RCPP
}
// window_corp_comp
SpMat window_corp_comp(SpMat& m1, SpMat& m2, NumericVector order1, NumericVector order2, int lwindow, int rwindow, double min_chi, double min_ratio, double smooth);
RcppExport SEXP _RNewsflow_window_corp_comp(SEXP m1SEXP, SEXP m2SEXP, SEXP order1SEXP, SEXP order2SEXP, SEXP lwindowSEXP, SEXP rwindowSEXP, SEXP min_chiSEXP, SEXP min_ratioSEXP, SEXP smoothSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SpMat& >::type m1(m1SEXP);
    Rcpp::traits::input_parameter< SpMat& >::type m2(m2SEXP);
    Rcpp::traits::input_parameter< NumericVector >::type order1(order1SEXP);
    Rcpp::traits::input_parameter< NumericVector >::type order2(order2SEXP);
    Rcpp::traits::input_parameter< int >::type lwindow(lwindowSEXP);
    Rcpp::traits::input_parameter< int >::type rwindow(rwindowSEXP);
    Rcpp::traits::input_parameter< double >::type min_chi(min_chiSEXP);
    Rcpp::traits::input_parameter< double >::type min_ratio(min_ratioSEXP);
    Rcpp::traits::input_parameter< double >::type smooth(smoothSEXP);
    rcpp_result_gen = Rcpp::wrap(window_corp_comp(m1, m2, order1, order2, lwindow, rwindow, min_chi, min_ratio, smooth));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_RNewsflow_term_union_cpp", (DL_FUNC) &_RNewsflow_term_union_cpp, 6},
    {"_RNewsflow_term_intersect_cpp", (DL_FUNC) &_RNewsflow_term_intersect_cpp, 6},
    {"_RNewsflow_batched_tcrossprod_cpp", (DL_FUNC) &_RNewsflow_batched_tcrossprod_cpp, 26},
    {"_RNewsflow_window_corp_comp", (DL_FUNC) &_RNewsflow_window_corp_comp, 9},
    {NULL, NULL, 0}
};

RcppExport void R_init_RNewsflow(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
